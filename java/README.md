### 1. 자바의 특징
  - #### 이식성  
    서로 다른 환경을 가진 시스템에 프로그램을 옮겨 실행할 수 있는 것을 의미 (JRE가 설치되어 있는 모든 O/S에서 실행 가능)
    
  - #### 객체지향 언어  
    부품에 해당하는 객체들을 생성, 조립, 연결하여 프로그래밍하는 기법  
    `캡슐화` `상속` `다형성`을 지원
    
    - `캡슐화`  
      - 필드, 메소드를 하나로 묶고 실제 구현내용을 감추는 기법  
      - 외부 객체는 공개된 메소드와 필드로만 이용 가능하기 때문에 외부 객체로 인한 객체의 손상을 줄일 수 있다.
    - `상속`  
      - 부모객체를 상속하여 자식객체를 생성함으로써 코드의 중복을 줄일 수 있다.  
      - 부모객체를 수정하면 상속 받은 자식객체도 자동으로 수정되므로 수정과 유지보수가 간편  
      다중 상속은 불가능
    - `다형성`  
      - 같은 타입을 입력함으로서 다양한 결과값을 얻을 수 있는 성질  
      - 부모타입에 모든 자식객체가 대입이 가능하고, 인터페이스에는 모든 구현객체 대입 가능
      
  - #### 함수형 프로그래밍 가능  
    람다식을 지원, 컬렉션 요소를 필터링, 매핑, 이벤트 처리가 쉬움
    
  - #### 메모리 자동 관리  
    자바는 개발자가 메모리를 직접 관리할 수 없다. GC가 사용하지 않는 메모리를 자동으로 제거
    
  - #### 쉬운 멀티스레드 구현  
    하나의 프로그램이 동시에 여러 작업을 처리해야할 경우, 대용량 작업을 빠르게 처리하기 위해서  
    서브 작업으로 분리해서 `병렬처리`하려면 멀티스레드가 필요  
    멀티스레드를 위한 API를 제공하기 때문에 구현이 간편함
    
  - #### 동적 로딩을 지원  
    어플리케이션을 실행할 때 모든 객체가 생성되지 않고, 객체의 필요에 따라 클래스를 로딩  
    유지보수를 할 때 어플리케이션 전체를 컴파일할 필요없이 해당 객체만 수정 가능하기 때문에 간편함  

  - #### OOP의 5대 원칙 (SOLID)
    -  S : 단일 책임 원칙 (SRP, Single Responsibility Principle)  
        - 객체는 단 하나의 책임만 가져야한다.
    - O : 개방-폐쇄 원칙 (OCP, Open Closed Principle)
        - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
    - L : 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)
        - 일반화 관계에 대한 이야기며 자식 클래스는 최소한 부모의 클래스에서 가능한 행위는 수행할 수 있어야한다.
    - I : 인터페이스 분리 원칙 (ISP, Interface Segregation Priciple)
        - 인테페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.
    - D : 의존 역전 원칙 (DIP, Dependency Inversion Principle)
      - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것
        거의 변화가 없는 것을 의존하라는 것이다.        

### 2. JVM (Java Virtual Machine)  
  - 컴파일러를 통해 생성된 파일은 (.class) 완전한 기계어가 아닌 바이트코드이므로 해석하고 실행하는 운영체제가 필요  
  JVM은 운영체제 대신에 이 역할을 수행함.
  
### 3. 변수
  - 하나의 값을 저장할 수 있는 메모리 공간
    - int 타입  
        기본적으로 연산의 결과는 int 타입으로 저장
        
    - long 타입  
        long 타입 데이터 뒤에 'L' 또는 'l' 을 붙이는 이유는 4바이트가 아닌 8바이트라는 것을 명시하기 위함
        
### 4. 자동 타입 변환
  - 큰 크기 타입 = 작은 크기 타입
  - byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)
  - 자동 타입 변환 시 'char = byte' 는 컴파일 에러 발생  
   char는 음수를 저장할 수 없기 때문에 자동 변환이 불가능 (0~6535)
  - 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 가장 큰 타입으로 자동 변환 후 연산  
    ex) double a = int a + double b 는 double로 자동 변환 후 저장

### 5. 강제 타입 변환
  - 작은 타입 = (작은 타입) 큰 타입


### 6. 증감 연산자 (++, --)
  - 'i+=1' 은 연산이 두 번 일어나므로 'i++'의 연산 속도가 더 빠르다.
  
### 7. 논리 연산자 (+ -, /, %)
  - '&&'는 앞에 있는 피연산자가 false일 경우 뒤에 있는 연산자를 판단하지 않고 결과값을 출력  
  '&' 앞, 뒤 피연산자를 판단하고 결과값을 내기 때문에 '&&'의 속도가 더 빠르다.

### 8. 비트 연산자 (&, |, ^, !)
  - 실수 타입은 비트 연산 불가능  
  - 비트 연산자는 피연산자를 int 타입으로 변경하여 연산을 수행하고 결과값 또한 int 타입  
    ex) byte result = byte & byte // 결과값이 int 타입이므로 에러 발생  
    
### 9, 클래스
  - 클래스로 부터 만들어진 객체를 인스턴스라 부르고 인스턴스 (객체) 생성 시  
  사용 가능한 필드와 메소드를 인스턴스 멤버라고 부른다.
  
### 10. 정적 멤버
  - 정적 멤버는 객체 생성 없이 사용 가능한 필드와 메소드를 의미  
  - 인스턴스 멤버는 생성사를 통해 객체 생성 후 사용이 가능하지만  
  정적 멤버는 클래스 로딩이 끝나면 바로 사용 가능  
  - 객체만의 고유한 특징은 인스턴스 멤버로 모든 객체가 가진 공통적인 특징은 정적 멤버로 사용하는 것이 좋다.  
  - 정적 멤버의 초기화는 정적 블록에서 가능  
  정적 블록은 클래스가 로딩될 때 자동으로 실행  
  - 인스턴스 멤버는 객체 생성 시 사용 가능하고 정적 메소드는 클래스 로딩 시 사용이 가능하기 때문에  
  인스턴스 멤버와 this를 사용할 수 없다  
  
  #### - 자바 메모리 영역  
  static 영역 : 정적 멤버  
  heap 영역 : new 연산자로 생성한 객체  
  stack 영역 : 매개변수, 지역변수

### 11. final 필드  
  - final 필드는 초기값이 설정되면 수정이 불가능  
  초기값은 필드 선언 시에 주는 방법과 생성자를 통화 선언하는 방법이 존재
  
### 12. 접근 제한자
  - public : 어디서든지 사용 가능
  - protected : 같은 패키지 또는 자식 클래스에서 사용 가능
  - default : 같은 패키지에서만 사용 가능
  - private : 내부 클래스에서만 사용 가능
  
### 13. 어노테이션
  - 어노테이션은 메타데이터라고 볼 수 있고 컴파일과 실행 과정에서 코드를 어떻게 컴파일하고 처리할지 알려주는 정보
  - 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 용도  
  런타임 시 특정 기능을 실행하도록 정보를 제공하는 용도로 사용한다.
  - '@Override'는 컴파일러에게 메소드가 재정의 되었는지 코드 문법 에러를 체크하는 용도로 사용
  
### 14. @Override
  - 부모의 메소드와  동일한 시그니처 (리턴 타입, 메소드명, 매개변수 목록)
  - 부모의 접근 제한자보다 수준을 더 높게 지정할 수 없다
  - 새로운 예외 throws 불가
  - 'public final void run()'과 같은 final 메소드는 오버라이드 불가능
  
### 15. 자동 타입 변환
  - 'Animal ani = new Dog();' 일 때 'ani'는 부모 클래스의 메소드와 필드는 접근이 가능하지만  
  자식 클래스의 필드와 메소드는 접근이 불가하다 (단, 오버라이드한 자식 클래스의 메소드는 접근 가능)
  
### 16. 추상 클래스  
  - 클래스의 공통적인 필드와 메소드를 추출하여 만든 클래스
  - 클래스의 필드와 메소드의 이름을 통일하기 위해 사용
  - 클래스의 공통적인 필드와 메소드를 추상 클래스에 기술하여 클래스의 개발 효율 증가
  - 추상 클래스는 new 연산자를 통해 객체 생성 불가능  
  - 클래스에서는 추상 클래스의 메소드를 오버라이딩하여 사용  

### 17. 인터페이스
  - 객체의 사용법을 정의한 설명서
  - 객체가 서로 통신하는 접점 역할을 수행
  - 개발 코드는 구현 객체의 내부 구조에 대한 이해 없이 메소드만으로 접근 가능
  - 다중 인터페이스 지원
  - 상수, 디폴트 메소드, 정적 메소드, 추상 메소드만을 구성 멤버로 가진다

### 18. super()
  - 자식 클래스의 생성자를 통해 객체 생성시 'super()'를 통해 부모 클래스를 먼저 생성  
  - 자신의 생성자를 호출하는 'this()'와 'super()'는 모두 첫 줄에서만 사용 가능  
  두 개 동시 사용 불가
  
### 19. 제네릭
  - 타입을 매개 변수로 갖는 클래스와 인터페이스를 의미
  - 컴파일 단계에서 타입을 체크하기 때문에 실행 시 발생할 수 있는 에러 방지
  - 불필요한 타입 변환을 제거
  
### 20. 제네릭 메소드
  - 매개 변수와 리턴값을 타입으로 갖는 메소드를 의미  
  ex) public <T> Box<T> boxing(T t) { ... }  
  Box<String> box = new Box<String>();
  box.boxing("LEE");
  
### 21. 컬렉션 프레임워크
  - 객체를 효율적으로 추가, 검색, 삭제하는 역할인 컬렉션과 사용법을 미리 정해놓은 라이브러리  
   
  Collection | List | 순서 유지하고 저장, 데이터 중복 가능 | ArrayList, Vector, LinkedList
  --- | --- | --- | ---
  | | Set | 순서 유지하지 않고 저장, 데이터 중복 불가능 | TreeSet, HashSet
  Map |   | 키와 값이 쌍으로 저장, 키 중복 불가, 값 중복 가능 | HashMap, HashTable
  
### 22. List 컬렉션
  - 객체를 저장하면 자동으로 인덱스가 부여되고 인덱스를 통해 데이터를 삭제, 조회 가능
  - 객체 자체를 저장하는 것이 아닌 객체의 주소 값을 통해 참조
  
    - #### ArrayList
        - List 인터페이스의 구현 클래스로서 인덱스를 통해 객체를 관리하는 것은 배열과 유사하지만  
        배열과 달리 저장 용량을 초과한 객체들이 삽입되면 유동적으로 저장 용량을 늘림
        - 자동으로 크기가 늘어나므로 크기를 지정할 필요없음
        - 제네릭을 도입했기 때문에 불필요한 타입 변환 불필요
        - 중간에 객체를 삽입 했을 경우 기존의 인덱스가 1씩 늘어나므로 
          삽입이 많은 곳에서는 LinkedList가 효율적이다
        - ArrayList 검색과 마지막 인덱스 객체 삽입에 효과적
        
    - #### Vector
        - 동기화된 메소드로 구성되었기 떄문에 멀티스레드가 동시에 실행할 수 없고 하나의 메소드가  
        완료되어야만 다른 메소드 실행 가능

    - #### LinkedList
        - ArrayList가 인덱스를 통해 관리하는 반면 LinkedList는 인접 참조를 통해 체인처럼 관리
        - 중간에 객체를 삽입했을 경우 인접 참조를 끊고 새로운 인접 참조를 만들기 때문에  
        객체의 중간에 삽입했을 때 ArrayList보다 빠르다

### 23. Set 컬렉션
  - 객체 순서를 유지하지 않고 데이터의 중복이 불가능 (Null도 하나만 저장 가능)
  - List와 달리 인덱스가 없기 때문에 Set 컬렉션의 모든 객체를 한 번씩 가져오는 Iterator 사용  
  ex) Set<String> set = new HashSet<String>();  
  Iterator<String> iterator = set.iterator();  
  while(iterator.hasNext()) {  
  &nbsp;&nbsp;&nbsp;&nbsp;String str = iterator.next();  
  }
  
### 24. Map 컬렉션
  - 키 객체와 값 객체를 쌍으로 저장, 키는 중복 불가, 값은 중복 가능
  
### 25. 이진 트리 구조
  - 검색 기능을 강화 시킨 컬렉션 프레임워크
  - 루트를 기준으로 왼쪽이 가장 작은 값, 오른쪽이 가장 큰 값으로 그룹핑이 잘 되었기 때문에 빠른 검색 가능
  
    - #### TreeSet  
        값을 비교해서 부모값보다 작은 객체는 왼쪽, 큰 객체는 오르쪽에 위치
        
    - #### TreeMap  
        TreeSet과 달리 키 객체와 값 객체가 쌍을 이룬 Map.Entry 를 저장하고 키 값을 비교해서 저장
        
### 26. 프로세스와 스레드
  - 운영체제에서 실행 중인 하나의 어플리케이션을 프로세스라고 부른다 (작업 단위)
  - 멀티프로세스는 어플리케이션 단위의 멀티태스킹이고 운영체제에서 받은 메모리로 실행되기  
  때문에 오류가 발생해도 서로 영향을 끼치지 않는다 (독립적)
  - 멀티스레드는 어플리케이션 내부에서의 멀티태스킹이고 어플리케이션 내부에서 동작하기 때문에  
  하나의 스레드에서 예외 발생 시 프로세스 종료
  - 싱글 스레드 어플리케이션에서는 메인 스레드가 종료되면 어플리케이션이 종료되지만  
  멀티 스레드 어플리케이션은 메인 스레드가 종료되어도 작업 스레드가 동작 중이면 프로세스는 종료되지 않는다.
  
### 27. 스레드 생성과 실행
  - Runnable 을 매개변수로 갖는 생성자를 호출해야한다. Runnable은 인터페이스므로 구현 객체를 생성해야한다.  
   ex) Thread thread = new Thread(new Runnable() {  
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run() { ... }   
    }
   )
   - Thread를 상속 받아서 생성  
   ex) public class task extends Thread {  
   &nbsp;&nbsp;&nbsp;&nbsp;@Override  
   &nbsp;&nbsp;&nbsp;&nbsp;public  void run() { ... }   
   }
 
 ### 28. 스레드 우선 순위
   - 동시성 : 하나의 코어에서 멀티태스킹을 위해 스레드가 번갈아가면 작업을 하는 성질
   - 병렬성 : 멀티 코어에서 여러개의 스레드가 동시에 작업이 되는 성질
   - 우선 순위 스케줄링 : 우선순위가 높은 스레드가 더 많이 실행되도록 스케줄링 하는 방식
   - Round Robin : 시간 할당량만큼 벌갈아가며 스레드를 실행하는 방식으로 제어 불가능
   
### 29. 동기화 메소드와 동기화 블록
  - 스레드 사용 중이 객체를 다른 스레드가 변경할 수 없도록 하려면 객체를 스레드 작업이  
  끝날 때까지 객체를 잠금해야한다. 그래서 멀티 스레드 프로그램에서 단 하나의 스레드만 실행  
  할 수 있는 코드 영역을 임계 영역이라고 한다. 
  
### 30. JPA란?
  - Java Persistence API의 약자
  - 자바 ORM의 기술 표준으로, 자바에서 RDB 사용하는 방식을 정의한 인터페이스 
  - Hibernate는 JPA를 구현한 오픈소스 (구현체)  
  Spring Data JPA는 JPA를 사용하기 쉽게 만든 모듈 (Repository 인터페이스 사용) 
  
### 31. JPA 사용 이유
  - CRUD 쿼리를 기본 제공하기 때문에 생산성에 좋다.
  - 쿼리가 아닌 객체를 통해 데이터베이스를 연동하기 때문에 유지보수에 용이하다.
  - 다양한 RDBMS를 사용하는 환경에서 쿼리를 수정할 필요가 없다.
  - 하지만, 통계와 같은 복잡한 쿼리보다 간단한 실시간 처리 쿼리에 더 최적화 되어있다.  
  `NativeQuery` 를 지원하고 있지만 세밀한 쿼리 작업이 필요한 경우에는 MyBatis와 혼용해서 사용할 것
  
### 32. JWT란?
  - JSON Web Token의 약자
  - JSON으로 전자 서명을 하여 문자열로 표현한 것
  - Header, Payload, Signiture로 나눠져 있음
  - Header : 토큰의 타입과 암호화 알고리즘을 담고 있음
  - Payload : 토큰에 담을 클레임 정보가 있음 (expired, username, authorities, jti, clientid, scope 등)
  - Signiture : Secret Key를 포함하여 암호화
  
### 33. JWT 사용 이유
  - 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요없다는 것입니다. 분산 마이크로 서비스 환경에서 중앙 집중식 인증 서버와 데이터베이스에 의존하지 않는 쉬운 인증 및 인가 방법을 제공
